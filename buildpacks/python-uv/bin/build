#!/usr/bin/env bash
set -eo pipefail

echo "---> Luban Python uv Buildpack"

# CNB_LAYERS_DIR, CNB_PLATFORM_DIR, CNB_BP_PLAN_PATH are provided by the lifecycle

# 1. Install uv
uv_layer="$CNB_LAYERS_DIR/uv"
mkdir -p "$uv_layer/bin"

# Determine uv version
DEFAULT_UV_VERSION="0.10.4"
UV_VERSION="$DEFAULT_UV_VERSION"

if [[ -f ".uv-version" ]]; then
    UV_VERSION=$(cat .uv-version | tr -d '[:space:]')
    echo "User requested uv version: $UV_VERSION"
fi

# Check cached version
CACHED_VERSION=""
if [[ -f "$uv_layer/version" ]]; then
    CACHED_VERSION=$(cat "$uv_layer/version")
fi

# Check if uv is cached and version matches, if not download
if [[ "$CACHED_VERSION" != "$UV_VERSION" ]] || [[ ! -f "$uv_layer/bin/uv" ]]; then
    echo "Installing uv $UV_VERSION..."
    ARCH=$(uname -m)
    if [[ "$ARCH" == "x86_64" ]]; then
        UV_URL="https://github.com/astral-sh/uv/releases/download/${UV_VERSION}/uv-x86_64-unknown-linux-musl.tar.gz"
    elif [[ "$ARCH" == "aarch64" ]]; then
        UV_URL="https://github.com/astral-sh/uv/releases/download/${UV_VERSION}/uv-aarch64-unknown-linux-musl.tar.gz"
    else
        echo "Unsupported architecture: $ARCH"
        exit 1
    fi
    
    # Download
    echo "Downloading uv from $UV_URL..."
    wget -q -O uv.tar.gz "$UV_URL"
    
    # Verify Checksum
    echo "Verifying checksum..."
    CHECKSUM_URL="${UV_URL}.sha256"
    wget -q -O uv.tar.gz.sha256 "$CHECKSUM_URL"
    
    EXPECTED_SHA256=$(cat uv.tar.gz.sha256 | cut -d' ' -f1)
    ACTUAL_SHA256=$(sha256sum uv.tar.gz | cut -d' ' -f1)
    
    if [[ "$ACTUAL_SHA256" != "$EXPECTED_SHA256" ]]; then
        echo "Error: Checksum mismatch!"
        echo "Expected: $EXPECTED_SHA256"
        echo "Actual:   $ACTUAL_SHA256"
        exit 1
    fi
    echo "Checksum verified."

    # Extract
    tar -xzf uv.tar.gz -C "$uv_layer/bin" --strip-components=1
    rm uv.tar.gz uv.tar.gz.sha256
    
    # Save version for caching
    echo "$UV_VERSION" > "$uv_layer/version"
    echo "uv installed."
else
    echo "Using cached uv $UV_VERSION"
fi

# Write layer metadata for uv
# launch=true ensures uv is available in the run image
cat <<EOF > "$uv_layer.toml"
[types]
cache = true
build = true
launch = true
EOF

export PATH="$uv_layer/bin:$PATH"

# 2. Configure uv paths
# We want Python toolchains to be cached and available at launch
python_layer="$CNB_LAYERS_DIR/python"
mkdir -p "$python_layer"
export UV_PYTHON_INSTALL_DIR="$python_layer"

# Write layer metadata for python
cat <<EOF > "$python_layer.toml"
[types]
cache = true
build = true
launch = true
EOF

# UV Cache for package downloads
uv_cache_layer="$CNB_LAYERS_DIR/uv_cache"
export UV_CACHE_DIR="$uv_cache_layer"

# Write layer metadata for uv cache (only needed for build)
cat <<EOF > "$uv_cache_layer.toml"
[types]
cache = true
build = true
EOF

# 3. Setup Virtual Environment Layer (Cached)
venv_layer="$CNB_LAYERS_DIR/venv"
mkdir -p "$venv_layer"
# Create symlink .venv -> venv_layer to persist venv across builds
rm -rf .venv
ln -s "$venv_layer" .venv

cat <<EOF > "$venv_layer.toml"
[types]
cache = true
build = true
launch = true
EOF

# 4. Install Python and Dependencies
echo "Installing dependencies with uv..."

# Ensure we are in the app directory (pwd is usually app dir)
# If uv.lock exists, use frozen, otherwise generate lock
if [[ -f "uv.lock" ]]; then
    uv sync --frozen
else
    uv sync
fi

# Prune cache to keep layer size optimized
echo "Pruning uv cache..."
uv cache prune

# 5. Set launch configuration
echo "Configuring launch..."

# Detect Execution Mode from pyproject.toml [tool.luban]
BP_EXECUTION_MODE="standard"
if [[ -f "pyproject.toml" ]]; then
    # Parse bp-execution-mode using sed/grep
    MODE=$(sed -n '/^\[tool.luban\]/,/^\[/p' pyproject.toml | grep 'bp-execution-mode' | cut -d'=' -f2 | tr -d ' "[:space:]' || true)
    if [[ -n "$MODE" ]]; then
        if [[ "$MODE" == "standard" || "$MODE" == "direct" ]]; then
            BP_EXECUTION_MODE="$MODE"
            echo "Detected bp-execution-mode: $BP_EXECUTION_MODE"
        else
            echo "Error: Invalid bp-execution-mode '$MODE'. Supported modes are 'standard' and 'direct'."
            exit 1
        fi
    fi
fi

# Detect Script Name from [project.scripts]
SCRIPT_NAME=""
if [[ -f "pyproject.toml" ]]; then
    echo "pyproject.toml found. Checking for [project.scripts]..."

    # Use bash to parse pyproject.toml for [project.scripts]
    SCRIPTS=$(sed -n '/^\[project.scripts\]/,/^\[/p' pyproject.toml | grep -v '^\[' | grep '=' | cut -d'=' -f1 | tr -d ' ' | tr '\n' ' ' || true)
    
    # Convert space-separated string to array
    read -r -a SCRIPT_KEYS <<< "$SCRIPTS"
    
    if [[ ${#SCRIPT_KEYS[@]} -eq 0 ]]; then
        echo "No scripts found in [project.scripts]"
    elif [[ ${#SCRIPT_KEYS[@]} -eq 1 ]]; then
        SCRIPT_NAME="${SCRIPT_KEYS[0]}"
    else
        # Heuristic: look for common names
        for name in "app" "start" "main" "run"; do
            for key in "${SCRIPT_KEYS[@]}"; do
                if [[ "$key" == "$name" ]]; then
                    SCRIPT_NAME="$name"
                    break 2
                fi
            done
        done
        
        # Fallback to first one if no common name found
        if [[ -z "$SCRIPT_NAME" ]]; then
            SCRIPT_NAME="${SCRIPT_KEYS[0]}"
        fi
    fi

    if [[ -n "$SCRIPT_NAME" ]]; then
        echo "Found entry point script: $SCRIPT_NAME"
    fi
else
    echo "No pyproject.toml found."
fi

# Generate launch.toml based on Mode
if [[ "$BP_EXECUTION_MODE" == "direct" ]]; then
    echo "Enabling direct execution mode..."
    
    # Create direct_exec wrapper
    cat <<EOF > "$venv_layer/bin/direct_exec"
#!/bin/sh
exec "\$@"
EOF
    chmod +x "$venv_layer/bin/direct_exec"
    
    if [[ -n "$SCRIPT_NAME" ]]; then
        echo "Setting default process 'scripts' to: direct_exec uv run $SCRIPT_NAME"
        cat <<EOF > "$CNB_LAYERS_DIR/launch.toml"
[[processes]]
type = "scripts"
command = ["$venv_layer/bin/direct_exec", "uv", "run", "$SCRIPT_NAME"]
default = true
EOF
    else
        echo "No script found. Setting default process 'scripts' to: direct_exec (ad-hoc)"
        cat <<EOF > "$CNB_LAYERS_DIR/launch.toml"
[[processes]]
type = "scripts"
command = ["$venv_layer/bin/direct_exec"]
default = true
EOF
    fi

else
    # Standard Mode
    if [[ -n "$SCRIPT_NAME" ]]; then
        echo "Setting default process 'scripts' to: uv run $SCRIPT_NAME"
        cat <<EOF > "$CNB_LAYERS_DIR/launch.toml"
[[processes]]
type = "scripts"
command = ["uv", "run", "$SCRIPT_NAME"]
default = true
EOF
    else
        echo "No scripts found. No default process set."
        echo "Please specify an args or command in your container configuration."
    fi
fi

echo "Build complete."
