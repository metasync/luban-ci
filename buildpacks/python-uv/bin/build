#!/usr/bin/env bash
set -eo pipefail

echo "---> Luban Python uv Buildpack"

# CNB_LAYERS_DIR, CNB_PLATFORM_DIR, CNB_BP_PLAN_PATH are provided by the lifecycle

# 1. Install uv
uv_layer="$CNB_LAYERS_DIR/uv"
mkdir -p "$uv_layer/bin"

# Determine uv version
DEFAULT_UV_VERSION="0.9.26"
UV_VERSION="$DEFAULT_UV_VERSION"

if [[ -f ".uv-version" ]]; then
    UV_VERSION=$(cat .uv-version | tr -d '[:space:]')
    echo "User requested uv version: $UV_VERSION"
fi

# Check cached version
CACHED_VERSION=""
if [[ -f "$uv_layer/version" ]]; then
    CACHED_VERSION=$(cat "$uv_layer/version")
fi

# Check if uv is cached and version matches, if not download
if [[ "$CACHED_VERSION" != "$UV_VERSION" ]] || [[ ! -f "$uv_layer/bin/uv" ]]; then
    echo "Installing uv $UV_VERSION..."
    ARCH=$(uname -m)
    if [[ "$ARCH" == "x86_64" ]]; then
        UV_URL="https://github.com/astral-sh/uv/releases/download/${UV_VERSION}/uv-x86_64-unknown-linux-musl.tar.gz"
    elif [[ "$ARCH" == "aarch64" ]]; then
        UV_URL="https://github.com/astral-sh/uv/releases/download/${UV_VERSION}/uv-aarch64-unknown-linux-musl.tar.gz"
    else
        echo "Unsupported architecture: $ARCH"
        exit 1
    fi
    
    # Download and extract
    wget -O- "$UV_URL" | tar -xz -C "$uv_layer/bin" --strip-components=1
    
    # Save version for caching
    echo "$UV_VERSION" > "$uv_layer/version"
    echo "uv installed."
else
    echo "Using cached uv $UV_VERSION"
fi

# Write layer metadata for uv
# launch=true ensures uv is available in the run image
cat <<EOF > "$uv_layer.toml"
[types]
cache = true
build = true
launch = true
EOF

export PATH="$uv_layer/bin:$PATH"

# 2. Configure uv paths
# We want Python toolchains to be cached and available at launch
python_layer="$CNB_LAYERS_DIR/python"
mkdir -p "$python_layer"
export UV_PYTHON_INSTALL_DIR="$python_layer"

# Write layer metadata for python
cat <<EOF > "$python_layer.toml"
[types]
cache = true
build = true
launch = true
EOF

# UV Cache for package downloads
uv_cache_layer="$CNB_LAYERS_DIR/uv_cache"
export UV_CACHE_DIR="$uv_cache_layer"

# Write layer metadata for uv cache (only needed for build)
cat <<EOF > "$uv_cache_layer.toml"
[types]
cache = true
build = true
EOF

# 3. Setup Virtual Environment Layer (Cached)
venv_layer="$CNB_LAYERS_DIR/venv"
mkdir -p "$venv_layer"
# Create symlink .venv -> venv_layer to persist venv across builds
rm -rf .venv
ln -s "$venv_layer" .venv

cat <<EOF > "$venv_layer.toml"
[types]
cache = true
build = true
launch = true
EOF

# 4. Install Python and Dependencies
echo "Installing dependencies with uv..."

# Ensure we are in the app directory (pwd is usually app dir)
# If uv.lock exists, use frozen, otherwise generate lock
if [[ -f "uv.lock" ]]; then
    uv sync --frozen --no-install-project
else
    uv sync --no-install-project
fi

# 5. Set launch configuration
echo "Configuring launch..."

# Handle launch configuration from pyproject.toml [project.scripts]
if [[ -f "pyproject.toml" ]]; then
    echo "pyproject.toml found. Checking for [project.scripts]..."

    # Use bash to parse pyproject.toml for [project.scripts]
    # 1. Extract section
    # 2. Filter out section headers
    # 3. Get keys (before =)
    # 4. Trim whitespace
    SCRIPTS=$(sed -n '/^\[project.scripts\]/,/^\[/p' pyproject.toml | grep -v '^\[' | grep '=' | cut -d'=' -f1 | tr -d ' ' | tr '\n' ' ')
    
    # Convert space-separated string to array
    read -r -a SCRIPT_KEYS <<< "$SCRIPTS"
    
    SCRIPT_NAME=""
    
    if [[ ${#SCRIPT_KEYS[@]} -eq 0 ]]; then
        echo "No scripts found in [project.scripts]"
    elif [[ ${#SCRIPT_KEYS[@]} -eq 1 ]]; then
        SCRIPT_NAME="${SCRIPT_KEYS[0]}"
    else
        # Heuristic: look for common names
        for name in "app" "start" "main" "run"; do
            for key in "${SCRIPT_KEYS[@]}"; do
                if [[ "$key" == "$name" ]]; then
                    SCRIPT_NAME="$name"
                    break 2
                fi
            done
        done
        
        # Fallback to first one if no common name found
        if [[ -z "$SCRIPT_NAME" ]]; then
            SCRIPT_NAME="${SCRIPT_KEYS[0]}"
        fi
    fi

    if [[ -n "$SCRIPT_NAME" ]]; then
        echo "Found entry point script: $SCRIPT_NAME"
        echo "Setting default process 'web' to: uv run $SCRIPT_NAME"
        
        cat <<EOF > "$CNB_LAYERS_DIR/launch.toml"
[[processes]]
type = "web"
command = ["uv", "run", "$SCRIPT_NAME"]
default = true
EOF
    else
        echo "No [project.scripts] found or unable to determine entry point."
        # We don't set a default process via Procfile anymore.
        # Users should provide the start command via Kubernetes Deployment 'command' or 'args'.
        echo "No default launch process set. Please specify an args or command in your container configuration."
    fi
else
    # We don't set a default process via Procfile anymore.
    # Users should provide the start command via Kubernetes Deployment 'command' or 'args'.
    echo "No pyproject.toml found. Please specify an args or command in your container configuration."
fi

echo "Build complete."
