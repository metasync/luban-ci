apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: argocd-project-setup-template
  namespace: luban-ci
spec:
  entrypoint: create-projects
  serviceAccountName: luban-ci-sa
  # Automatically delete the workflow (and pods) after a delay to clean up
  ttlStrategy:
    secondsAfterCompletion: 86400 # 24 hours
    secondsAfterSuccess: 3600     # 1 hour
    secondsAfterFailure: 86400    # 24 hours
  arguments:
    parameters:
    - name: project_name
      description: "Name of the project/team (e.g., 'payment')"
    - name: environment
      description: "Target environment (e.g., 'snd', 'prd')"
      value: "snd"
    - name: git_organization
      description: "Git Organization/User (defaults to project_name if empty)"
      value: ""
    - name: git_provider
      description: "Git Provider (e.g., 'github', 'gitlab')"
      value: "github"
    - name: developer_groups
      description: "List of OIDC groups for developer access (JSON array)"
      value: '[]'
    - name: admin_groups
      description: "List of OIDC groups for admin access (JSON array)"
      value: '[]'
    - name: create_test_users
      description: "Create local ServiceAccounts for testing RBAC (yes/no)"
      value: "no"
      enum:
      - "yes"
      - "no"
    - name: image_pull_secret
      description: "Name of the secret to copy to project namespaces"
      valueFrom:
        configMapKeyRef:
          name: luban-config
          key: image_pull_secret
          optional: true
    - name: gitops_utils_image
      description: "Image for GitOps utility tools"
      value: "quay.io/luban-ci/gitops-utils:0.3.3"
  templates:
  - name: create-projects
    inputs:
      parameters:
      - name: environment
    steps:
    - - name: ensure-project
        template: ensure-project
        arguments:
          parameters:
          - name: environment
            value: "{{inputs.parameters.environment}}"
          - name: project_name
            value: "{{workflow.parameters.project_name}}"
          - name: git_provider
            value: "{{workflow.parameters.git_provider}}"
          - name: git_organization
            value: "{{workflow.parameters.git_organization}}"

  - name: ensure-project
    inputs:
      parameters:
      - name: environment
      - name: project_name
      - name: git_provider
      - name: git_organization
    steps:
    - - name: check-exists
        template: check-project-exists
        arguments:
          parameters:
          - name: environment
            value: "{{inputs.parameters.environment}}"
          - name: project_name
            value: "{{inputs.parameters.project_name}}"
    - - name: create-project
        template: create-project-resource
        arguments:
          parameters:
          - name: environment
            value: "{{inputs.parameters.environment}}"
          - name: project_name
            value: "{{inputs.parameters.project_name}}"
          - name: git_provider
            value: "{{inputs.parameters.git_provider}}"
          - name: git_organization
            value: "{{inputs.parameters.git_organization}}"
        when: "{{steps.check-exists.outputs.result}} == false"
    - - name: bootstrap-namespace
        template: bootstrap-namespace
        arguments:
          parameters:
          - name: environment
            value: "{{inputs.parameters.environment}}"

  - name: bootstrap-namespace
    inputs:
      parameters:
      - name: environment
    script:
      image: "{{workflow.parameters.gitops_utils_image}}"
      command: [sh]
      source: |
        TARGET_NS="{{inputs.parameters.environment}}-{{workflow.parameters.project_name}}"
        CREATE_TEST_USERS="{{workflow.parameters.create_test_users}}"
        
        # 1. Create Namespace
        echo "Ensuring namespace $TARGET_NS exists..."
        kubectl create ns $TARGET_NS --dry-run=client -o yaml | kubectl apply -f -
        
        # 2. Copy Image Pull Secret
        echo "Copying {{workflow.parameters.image_pull_secret}} to $TARGET_NS..."
        kubectl get secret {{workflow.parameters.image_pull_secret}} -n luban-ci -o json | \
        jq 'del(.metadata.namespace,.metadata.resourceVersion,.metadata.uid,.metadata.creationTimestamp)' | \
        kubectl apply -n $TARGET_NS -f -
        
        # 2b. Copy Luban Config
        echo "Copying luban-config to $TARGET_NS..."
        kubectl get configmap luban-config -n luban-ci -o json | \
        jq 'del(.metadata.namespace,.metadata.resourceVersion,.metadata.uid,.metadata.creationTimestamp)' | \
        kubectl apply -n $TARGET_NS -f -
        
        # 2c. Copy Workflow Semaphores
        echo "Copying workflow-semaphores to $TARGET_NS..."
        kubectl get configmap workflow-semaphores -n luban-ci -o json | \
        jq 'del(.metadata.namespace,.metadata.resourceVersion,.metadata.uid,.metadata.creationTimestamp)' | \
        kubectl apply -n $TARGET_NS -f -

        # 2d. Copy GitHub Creds
        echo "Copying github-creds to $TARGET_NS..."
        if kubectl get secret github-creds -n luban-ci > /dev/null 2>&1; then
           kubectl get secret github-creds -n luban-ci -o json | \
           jq 'del(.metadata.namespace,.metadata.resourceVersion,.metadata.uid,.metadata.creationTimestamp)' | \
           kubectl apply -n $TARGET_NS -f -
        else
           echo "Warning: github-creds secret not found in luban-ci. Skipping copy."
        fi
        
        # 3. Patch default ServiceAccount
        echo "Patching default ServiceAccount in $TARGET_NS..."
        kubectl patch sa default -n $TARGET_NS -p '{"imagePullSecrets": [{"name": "{{workflow.parameters.image_pull_secret}}"}]}'

        # 4. Create workflow-runner ServiceAccount
        echo "Creating workflow-runner ServiceAccount in $TARGET_NS..."
        kubectl create sa workflow-runner -n $TARGET_NS --dry-run=client -o yaml | kubectl apply -f -
        
        # Patch workflow-runner with secrets (for kpack builds)
        # It needs both pull secrets (for base images) and regular secrets (for pushing)
        kubectl patch sa workflow-runner -n $TARGET_NS -p '{"imagePullSecrets": [{"name": "{{workflow.parameters.image_pull_secret}}"}], "secrets": [{"name": "{{workflow.parameters.image_pull_secret}}"}, {"name": "github-creds"}]}'

        # Bind workflow-runner to admin role in namespace (for Kpack/Deployment management)
        echo "Binding workflow-runner to admin role..."
        kubectl create rolebinding workflow-runner-admin \
          --clusterrole=admin \
          --serviceaccount=$TARGET_NS:workflow-runner \
          -n $TARGET_NS --dry-run=client -o yaml | kubectl apply -f -

        # Bind workflow-runner to luban-kpack-reader ClusterRole (to see ClusterBuilder)
        kubectl create clusterrolebinding workflow-runner-kpack-reader-$TARGET_NS \
          --clusterrole=luban-kpack-reader \
          --serviceaccount=$TARGET_NS:workflow-runner \
          --dry-run=client -o yaml | kubectl apply -f -

        # Bind workflow-runner to luban-kpack-admin ClusterRole (to manage Kpack resources in namespace)
        # Note: We use RoleBinding here (not ClusterRoleBinding) to restrict access to the namespace
        kubectl create rolebinding workflow-runner-kpack-admin \
          --clusterrole=luban-kpack-admin \
          --serviceaccount=$TARGET_NS:workflow-runner \
          -n $TARGET_NS \
          --dry-run=client -o yaml | kubectl apply -f -
        
        # 5. Configure RBAC for OIDC Groups
        ADMIN_GROUPS='{{workflow.parameters.admin_groups}}'
        DEV_GROUPS='{{workflow.parameters.developer_groups}}'
        
        # Helper function to generate RoleBinding subjects from JSON array
        generate_subjects() {
          local groups="$1"
          local sa_name="$2"
          
          # Add OIDC groups
          if [ -n "$groups" ] && [ "$groups" != "[]" ]; then
             echo "$groups" | jq -r '.[]' | while read group; do
                if [ -n "$group" ]; then
                  echo "- kind: Group"
                  echo "  name: $group"
                  echo "  apiGroup: rbac.authorization.k8s.io"
                fi
             done
          fi
          
          # Add ServiceAccount if specified
          if [ -n "$sa_name" ]; then
             echo "- kind: ServiceAccount"
             echo "  name: $sa_name"
             echo "  namespace: $TARGET_NS"
          fi
        }

        TEST_ADMIN_SA=""
        TEST_DEV_SA=""

        if [ "$CREATE_TEST_USERS" = "yes" ]; then
           echo "Creating test users (ServiceAccounts)..."
           # Create SAs and annotate them with default-namespace
           kubectl create sa test-project-admin -n $TARGET_NS --dry-run=client -o yaml | \
             kubectl annotate -f - --local "workflows.argoproj.io/default-namespace=$TARGET_NS" -o yaml | \
             kubectl apply -f -
             
           kubectl create sa test-project-developer -n $TARGET_NS --dry-run=client -o yaml | \
             kubectl annotate -f - --local "workflows.argoproj.io/default-namespace=$TARGET_NS" -o yaml | \
             kubectl apply -f -
             
           TEST_ADMIN_SA="test-project-admin"
           TEST_DEV_SA="test-project-developer"
        fi

        # Apply Admin RoleBinding
        echo "Creating project-admins RoleBinding..."
        cat <<EOF | kubectl apply -f -
        apiVersion: rbac.authorization.k8s.io/v1
        kind: RoleBinding
        metadata:
          name: project-admins
          namespace: $TARGET_NS
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: ClusterRole
          name: admin
        subjects:
        $(generate_subjects "$ADMIN_GROUPS" "$TEST_ADMIN_SA")
        EOF

        # Apply Developer RoleBinding (Edit Role)
        echo "Creating project-developers RoleBinding..."
        cat <<EOF | kubectl apply -f -
        apiVersion: rbac.authorization.k8s.io/v1
        kind: RoleBinding
        metadata:
          name: project-developers
          namespace: $TARGET_NS
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: ClusterRole
          name: edit
        subjects:
        $(generate_subjects "$DEV_GROUPS" "$TEST_DEV_SA")
        EOF

        # Apply ClusterRoleBinding for viewing templates
        echo "Creating view-templates ClusterRoleBinding..."
        cat <<EOF | kubectl apply -f -
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRoleBinding
        metadata:
          name: view-templates-$TARGET_NS
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: ClusterRole
          name: luban-view-templates
        subjects:
        $(generate_subjects "$ADMIN_GROUPS" "$TEST_ADMIN_SA")
        $(generate_subjects "$DEV_GROUPS" "$TEST_DEV_SA")
        EOF

  - name: check-project-exists
    inputs:
      parameters:
      - name: environment
      - name: project_name
    script:
      image: "{{workflow.parameters.gitops_utils_image}}"
      command: [sh]
      source: |
        PROJECT_NAME="{{inputs.parameters.environment}}-{{inputs.parameters.project_name}}"
        echo "Checking if ArgoCD project $PROJECT_NAME exists..." >&2
        if kubectl get appproject $PROJECT_NAME -n argocd > /dev/null 2>&1; then
          echo "Project $PROJECT_NAME already exists." >&2
          echo "true"
        else
          echo "Project $PROJECT_NAME does not exist." >&2
          echo "false"
        fi

  - name: create-project-resource
    inputs:
      parameters:
      - name: environment
      - name: project_name
      - name: git_provider
      - name: git_organization
    container:
      image: "{{workflow.parameters.gitops_utils_image}}"
      command: [sh, -c]
      args:
      - |
        # Calculate derived parameters in shell for robustness
        ORG="{{inputs.parameters.git_organization}}"
        if [ -z "$ORG" ]; then
          ORG="{{inputs.parameters.project_name}}"
        fi
        
        GITOPS_REPOS_WHITELIST="https://{{inputs.parameters.git_provider}}.com/${ORG}/*"
        
        echo "Creating AppProject {{inputs.parameters.environment}}-{{inputs.parameters.project_name}}..."
        
        cat <<EOF | kubectl apply -f -
        apiVersion: argoproj.io/v1alpha1
        kind: AppProject
        metadata:
          name: {{inputs.parameters.environment}}-{{inputs.parameters.project_name}}
          namespace: argocd
        spec:
          description: {{inputs.parameters.project_name}} team project for {{inputs.parameters.environment}} environment
          sourceRepos: 
          - "${GITOPS_REPOS_WHITELIST}"
          destinations:
          - namespace: {{inputs.parameters.environment}}-{{inputs.parameters.project_name}}
            server: https://kubernetes.default.svc
          - namespace: gateway
            server: https://kubernetes.default.svc
          clusterResourceWhitelist:
          - group: '*'
            kind: '*'
          namespaceResourceWhitelist:
          - group: '*'
            kind: '*'
          roles:
          - name: project-developer
            description: Developer role with read and sync access
            groups: {{workflow.parameters.developer_groups}}
            policies:
            - "p, proj:{{inputs.parameters.environment}}-{{inputs.parameters.project_name}}:project-developer, applications, get, {{inputs.parameters.environment}}-{{inputs.parameters.project_name}}/*, allow"
            - "p, proj:{{inputs.parameters.environment}}-{{inputs.parameters.project_name}}:project-developer, applications, sync, {{inputs.parameters.environment}}-{{inputs.parameters.project_name}}/*, allow"
          - name: project-admin
            description: Admin role with full access
            groups: {{workflow.parameters.admin_groups}}
            policies:
            - "p, proj:{{inputs.parameters.environment}}-{{inputs.parameters.project_name}}:project-admin, applications, *, {{inputs.parameters.environment}}-{{inputs.parameters.project_name}}/*, allow"
        EOF
